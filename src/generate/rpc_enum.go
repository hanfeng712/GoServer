/***********************************************************************
* @ 生成 rpc enum
* @ brief
	1、“生成rpc注册代码”，记录途中提取到的Rpc函数名

	2、解析 generate_out/rpc/enum/generate_rpc_enum.go，得到 Rpc 枚举表

	3、遍历Rpc函数名，同枚举比对，有新函数时才追加枚举，保障兼容性、编译友好性

* @ 手动指定枚举顺序
	、编辑 generate_rpc_enum.go 删除尾部其它枚举，再次生成即可
	、开头几个 Rpc 是系统保留的，供底层使用，不要删除

* @ author zhoumf
* @ date 2017-10-17
***********************************************************************/
package main

import (
	"bytes"
	"common"
	"os"
	"regexp"
	"text/template"
)

const (
	K_EnumOutDir     = K_OutDir + "rpc/enum/"
	K_EnumFileName   = "generate_rpc_enum"
	K_EnumOutDir_C   = "../../CXServer/src/rpc/"
	K_EnumOutDir_CS  = "../../GameClient/Assets/RGScript/generate/"
	K_RpcFuncFile_C  = "../../CXServer/src/rpc/RpcEnum.h"
	K_RpcFuncFile_CS = "../../GameClient/Assets/RGScript/Net/Player/Player.cs"
)

type TRpcEunm struct {
	Name string
	ID   uint16
}

// -------------------------------------
// 收集各处的 Rpc 函数名，小写开头
var (
	g_rpc_enum []TRpcEunm
	g_rpc_func []string
)

func collectRpc_Go(info *RpcInfo) {
	for _, v := range info.TcpRpc {
		g_rpc_func = append(g_rpc_func, "r"+v.Name[1:])
	}
	for _, v := range info.HttpRpc {
		g_rpc_func = append(g_rpc_func, "r"+v.Name[1:])
	}
	for _, v := range info.HttpPlayerRpc {
		g_rpc_func = append(g_rpc_func, "r"+v.Name[1:])
	}
}
func collectRpc_C() {
	reg := regexp.MustCompile(`rpc_\w+`)
	common.ReadLine(K_RpcFuncFile_C, func(line string) {
		if result := reg.FindAllString(line, -1); result != nil {
			g_rpc_func = append(g_rpc_func, result[0])
		}
	})
}
func collectRpc_CSharp() {
	reg := regexp.MustCompile(`rpc_\w+`)
	common.ReadLine(K_RpcFuncFile_CS, func(line string) {
		if ok, _ := regexp.MatchString(`^public void rpc_.+`, line); ok {
			g_rpc_func = append(g_rpc_func, reg.FindAllString(line, -1)[0])
		}
	})
}
func collectOldEnum() {
	reg := regexp.MustCompile(`Rpc_\w+`)
	common.ReadLine(K_EnumOutDir+K_EnumFileName+".go", func(line string) {
		if result := reg.FindAllString(line, -1); result != nil {
			rpcname := "r" + result[0][1:]
			g_rpc_enum = append(g_rpc_enum, TRpcEunm{Name: rpcname})
		}
	})
}
func isNewRpc(name string) bool { //新名字的rpc才生成枚举
	for _, v := range g_rpc_enum {
		if v.Name == name {
			return false
		}
	}
	return true
}

// -------------------------------------
// 生成枚举代码
func generatRpcEnum() {

	collectOldEnum() //当前枚举，将新增RpcFunc加入后重新生成

	haveNewRpc := false
	for _, name := range g_rpc_func {
		if isNewRpc(name) {
			g_rpc_enum = append(g_rpc_enum, TRpcEunm{Name: name})
			haveNewRpc = true
		}
	}
	if !haveNewRpc { //没有新rpc，就不改动文件了，编译更友好
		print("no new rpc, don't change enum.h\n")
		return
	}
	g_rpc_enum = append(g_rpc_enum, TRpcEunm{"RpcEnumCnt", uint16(len(g_rpc_enum)) + 1})

	autoIncId := uint16(1)
	for i := 0; i < len(g_rpc_enum); i++ {
		g_rpc_enum[i].ID = autoIncId
		autoIncId++
	}
	makeEnumFile_C(g_rpc_enum)
	makeEnumFile_Go(g_rpc_enum)
	makeEnumFile_CSharp(g_rpc_enum)
}

// -------------------------------------
// -- 填充模板 golang
const codeEnumTemplate1 = `
// Generated by GoServer/src/generat
// Don't edit !
package enum
const (
	{{range $_, $v := .}}{{RpcNameCapitalize $v.Name}} uint16 = {{$v.ID}}
	{{end}}
)
`

func makeEnumFile_Go(data interface{}) {
	filename := K_EnumFileName + ".go"
	var err error
	tpl := template.New(filename).Funcs(map[string]interface{}{
		"RpcNameCapitalize": RpcNameCapitalize,
	})
	if tpl, err = tpl.Parse(codeEnumTemplate1); err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_EnumOutDir, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_EnumOutDir+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
func RpcNameCapitalize(rpc string) string { return "R" + rpc[1:] }

// -------------------------------------
// -- 填充模板 c++
const codeEnumTemplate2 = `
// Generated by GoServer/src/generat
// Don't edit !
#define Rpc_Enum\
	{{range $_, $v := .}}_Declare({{$v.Name}}, {{$v.ID}})\
	{{end}}


#undef _Declare
#define _Declare(k, v) k = v,
enum RpcEnum:uint16 {
    Rpc_Enum
};
inline const char* RpcIdToName(int id) {
#ifdef _DEBUG
    static std::map<int, const char*> g_rpc_func;
    if (g_rpc_func.empty()) {
#undef _Declare
#define _Declare(k, v) g_rpc_func[v] = #k;
        Rpc_Enum
    }
    return g_rpc_func[id];
#else
    static char str[16];
    sprintf(str, "%d", id);
    return str;
#endif
}
`

func makeEnumFile_C(data interface{}) {
	filename := K_EnumFileName + ".h"
	tpl, err := template.New(filename).Parse(codeEnumTemplate2)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_EnumOutDir_C, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_EnumOutDir_C+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}

// -------------------------------------
// -- 填充模板 c#
const codeEnumTemplate3 = `
// Generated by GoServer/src/generat
// Don't edit !
public enum RpcEnum: System.UInt16 {
	{{range $_, $v := .}}{{$v.Name}} = {{$v.ID}},
	{{end}}
}
`

func makeEnumFile_CSharp(data interface{}) {
	filename := K_EnumFileName + ".cs"
	tpl, err := template.New(filename).Parse(codeEnumTemplate3)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_EnumOutDir_CS, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_EnumOutDir_CS+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
