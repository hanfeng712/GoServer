/***********************************************************************
* @ 生成 rpc enum
* @ brief
	1、“生成rpc注册代码”，记录途中提取到的Rpc函数名

	2、解析 generate_out/rpc/enum/generate_rpc_enum.go，得到 Rpc 枚举表

	3、遍历Rpc函数名，同枚举比对，有新函数时才追加枚举，保障兼容性、编译友好性

* @ 手动指定枚举顺序
	、编辑 generate_rpc_enum.go 删除尾部其它枚举，再次生成即可
	、开头几个 Rpc 是系统保留的，供底层使用，不要删除

* @ author zhoumf
* @ date 2017-10-17
***********************************************************************/
package main

import (
	"bytes"
	"common"
	"common/file"
	"os"
	"regexp"
	"strings"
	"text/template"
)

const (
	K_EnumOutDir     = K_OutDir + "rpc/enum/"
	K_EnumFileName   = "generate_rpc_enum"
	K_EnumOutDir_C   = "../../CXServer/src/rpc/"
	K_EnumOutDir_CS  = "../../GameClient/Assets/RGScript/generate/"
	K_RpcFuncFile_C  = "../../CXServer/src/rpc/RpcEnum.h"
	K_RpcFuncFile_CS = "../../GameClient/Assets/RGScript/Net/Player/Player.cs"

	Logic_RpcEnum_Begin = 100 //之前的预留给系统层用
)

// -------------------------------------
// 收集各处的 Rpc 函数名，小写开头
func addRpc_Go(funcs *[]string, info *RpcInfo) {
	for _, v := range info.TcpRpc {
		*funcs = append(*funcs, "r"+v.Name[1:])
	}
	for _, v := range info.HttpRpc {
		*funcs = append(*funcs, "r"+v.Name[1:])
	}
	for _, v := range info.PlayerRpc {
		*funcs = append(*funcs, "r"+v.Name[1:])
	}
}
func addRpc_C(funcs *[]string) {
	reg := regexp.MustCompile(`rpc_\w+`)
	file.ReadLine(K_RpcFuncFile_C, func(line string) {
		if result := reg.FindAllString(line, -1); result != nil {
			*funcs = append(*funcs, result[0])
		}
	})
}
func addRpc_CS(funcs *[]string) {
	reg := regexp.MustCompile(`rpc_\w+`)
	file.ReadLine(K_RpcFuncFile_CS, func(line string) {
		if ok, _ := regexp.MatchString(`^public void rpc_`, line); ok {
			*funcs = append(*funcs, reg.FindAllString(line, -1)[0])
		}
	})
}
func getOldEnum() (enums []common.KeyPair, enumCnt int) {
	reg := regexp.MustCompile(`^Rpc_\w+`)
	file.ReadLine(K_EnumOutDir+K_EnumFileName+".go", func(line string) {
		if ok, _ := regexp.MatchString(`^Rpc_\w+ uint16`, line); ok {
			if result := reg.FindAllString(line, -1); result != nil {
				rpcname := "r" + result[0][1:]
				list := strings.Split(line, " ")
				rid := common.CheckAtoiName(list[len(list)-1])
				enums, enumCnt = append(enums, common.KeyPair{rpcname, rid}), rid+1
				if enumCnt < Logic_RpcEnum_Begin {
					enumCnt = Logic_RpcEnum_Begin
				}
			}
		}
	})
	return
}
func isRpcIn(enums []common.KeyPair, rpcName string) bool {
	for _, v := range enums {
		if v.Name == rpcName {
			return true
		}
	}
	return false
}

// -------------------------------------
// 生成枚举代码
func generatRpcEnum(funcs []string) bool {
	enums, enumCnt := getOldEnum() //旧枚举，将新增RpcFunc加入后重新生成
	haveNewRpc := false
	for _, name := range funcs {
		if !isRpcIn(enums, name) {
			enums = append(enums, common.KeyPair{name, enumCnt})
			haveNewRpc = true
			enumCnt++
		}
	}
	if !haveNewRpc { //没有新rpc，就不改动文件了，编译更友好
		print("no new rpc, don't change enum.h\n")
		return false
	}
	enums = append(enums, common.KeyPair{"RpcEnumCnt", enumCnt})

	makeEnumFile_C(enums)
	makeEnumFile_Go(enums)
	makeEnumFile_CSharp(enums)
	return true
}

// -------------------------------------
// -- 填充模板 golang
const codeEnumTemplate1 = `// Generated by GoServer/src/generat
// Don't edit !
package enum
const ( //the top 100 rpc are reserved for net system
	{{range $_, $v := .}}{{RpcNameCapitalize $v.Name}} uint16 = {{$v.ID}}
	{{end}}
)
`

func makeEnumFile_Go(data interface{}) {
	filename := K_EnumFileName + ".go"
	var err error
	tpl := template.New(filename).Funcs(map[string]interface{}{
		"RpcNameCapitalize": RpcNameCapitalize,
	})
	if tpl, err = tpl.Parse(codeEnumTemplate1); err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_EnumOutDir, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_EnumOutDir+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
func RpcNameCapitalize(rpc string) string { return "R" + rpc[1:] }

// -------------------------------------
// -- 填充模板 c++
const codeEnumTemplate2 = `// Generated by GoServer/src/generat
// Don't edit !
#define Rpc_Enum\
	{{range $_, $v := .}}_Declare({{$v.Name}}, {{$v.ID}})\
	{{end}}


#undef _Declare
#define _Declare(k, v) k = v,
enum RpcEnum:uint16 {
    Rpc_Enum
};
inline const char* RpcIdToName(int id) {
#ifdef _DEBUG
    static std::map<int, const char*> g_rpc_func;
    if (g_rpc_func.empty()) {
#undef _Declare
#define _Declare(k, v) g_rpc_func[v] = #k;
        Rpc_Enum
    }
    return g_rpc_func[id];
#else
    static char str[16];
    sprintf(str, "%d", id);
    return str;
#endif
}
`

func makeEnumFile_C(data interface{}) {
	filename := K_EnumFileName + ".h"
	tpl, err := template.New(filename).Parse(codeEnumTemplate2)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_EnumOutDir_C, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_EnumOutDir_C+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}

// -------------------------------------
// -- 填充模板 c#
const codeEnumTemplate3 = `// Generated by GoServer/src/generat
// Don't edit !
public enum RpcEnum: System.UInt16 {
	{{range $_, $v := .}}{{$v.Name}} = {{$v.ID}},
	{{end}}
}
`

func makeEnumFile_CSharp(data interface{}) {
	filename := K_EnumFileName + ".cs"
	tpl, err := template.New(filename).Parse(codeEnumTemplate3)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, data); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_EnumOutDir_CS, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_EnumOutDir_CS+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
