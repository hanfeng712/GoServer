/***********************************************************************
* @ 生成RpcFunc注册代码
* @ brief
	1、用正则表达式检测各个服务器源码中的 Rpc_* 函数，提取函数名

	2、golang 部分，函数散列在各处，所以遍历了源文件

	3、c++、c# 部分，函数均在固定文件有记录，只需解析单个文件即可

* @ author zhoumf
* @ date 2017-10-17
***********************************************************************/
package main

import (
	"bytes"
	"common/file"
	"os"
	"path/filepath"
	"regexp"
	"text/template"
)

const (
	K_RegistOutDir   = K_OutDir + "rpc/"
	K_RegistFileName = "generate_rpc.go"
)

type Func struct {
	Pack string //函数所在包名
	Name string //函数名
}
type RpcInfo struct {
	Module     string          //模块名：game、login、gateway...
	PackDirs   map[string]bool //import需要：rpc涉及到的包路径
	TcpRpc     []Func
	HttpRpc    []Func
	PlayerRpc  []Func
	HttpHandle []Func

	RegPlayerRpcPack string //玩家rpc注册函数所在包名
}

func generatRpcRegist(svr string) *RpcInfo {
	pinfo := &RpcInfo{Module: GetModuleName(svr), PackDirs: make(map[string]bool)}
	names, _ := file.WalkDir(K_SvrDir+svr, ".go")
	for _, v := range names {
		packdir, pack := "", ""
		file.ReadLine(v, func(line string) {
			fname := "" //func name
			if packdir == "" {
				packdir = filepath.ToSlash(filepath.Dir(v)[len(K_SvrDir):])
				pack = getPackage(packdir)
			} else if fname = getTcpRpc(line); fname != "" {
				pinfo.TcpRpc = append(pinfo.TcpRpc, Func{pack, fname})
			} else if fname = getHttpRpc(line); fname != "" {
				pinfo.HttpRpc = append(pinfo.HttpRpc, Func{pack, fname})
			} else if fname = getHttpHandle(line); fname != "" {
				pinfo.HttpHandle = append(pinfo.HttpHandle, Func{pack, fname})
			} else if fname = getPlayerRpc(line); fname != "" {
				pinfo.PlayerRpc = append(pinfo.PlayerRpc, Func{pack, fname})
			} else if fname = getRegPlayerRpc(line); fname != "" {
				pinfo.RegPlayerRpcPack = pack
			}
			if packdir != "" && fname != "" {
				pinfo.PackDirs[packdir] = true
			}
		})
	}
	pinfo.makeFile(svr)
	return pinfo
}

// -------------------------------------
// -- 提取 package、RpcFunc
func getPackage(dir string) string { return filepath.Base(dir) }
func getTcpRpc(s string) string {
	if ok, _ := regexp.MatchString(`^func Rpc_\w+\(\w+, \w+ \*common.NetPack, \w+ \*tcp.TCPConn\) \{`, s); ok {
		reg := regexp.MustCompile(`Rpc_\w+`)
		return reg.FindAllString(s, -1)[0]
	}
	return ""
}
func getHttpRpc(s string) string {
	if ok, _ := regexp.MatchString(`^func Rpc_\w+\(\w+, \w+ \*common.NetPack\) \{`, s); ok {
		reg := regexp.MustCompile(`Rpc_\w+`)
		return reg.FindAllString(s, -1)[0]
	}
	return ""
}
func getPlayerRpc(s string) string {
	if ok, _ := regexp.MatchString(`^func Rpc_\w+\(\w+, \w+ \*common.NetPack, this \*.+\) \{`, s); ok {
		reg := regexp.MustCompile(`Rpc_\w+`)
		return reg.FindAllString(s, -1)[0]
	}
	return ""
}
func getHttpHandle(s string) string {
	if ok, _ := regexp.MatchString(`^func Http_\w+\(\w+ http.ResponseWriter, \w+ \*http.Request\) \{`, s); ok {
		reg := regexp.MustCompile(`Http_\w+`)
		return reg.FindAllString(s, -1)[0][5:]
	}
	return ""
}
func getRegPlayerRpc(s string) string {
	if ok, _ := regexp.MatchString(`^func RegPlayerRpc\(\w+ map\[uint16\]PlayerRpc\) \{`, s); ok {
		return "RegPlayerRpc"
	}
	return ""
}

// -------------------------------------
// -- 填充模板
const codeRegistTemplate = `// Generated by GoServer/src/generat
// Don't edit !
package rpc
import (
	"netConfig/register"
	{{if .RpcCnt}}"generate_out/rpc/enum"{{end}}
	{{range $k, $_ := .PackDirs}}"{{$k}}"
	{{end}}
)
func init() {
	{{if .TcpRpcCnt}}
		register.RegTcpRpc(map[uint16]register.TcpRpc{
			{{range .TcpRpc}}enum.{{.Name}}: {{.Pack}}.{{.Name}},
			{{end}}
		})
	{{end}}
	{{if .HttpRpcCnt}}
		register.RegHttpRpc(map[uint16]register.HttpRpc{
			{{range .HttpRpc}}enum.{{.Name}}: {{.Pack}}.{{.Name}},
			{{end}}
		})
	{{end}}
	{{if .PlayerRpcCnt}}
		{{.RegPlayerRpcPack}}.RegPlayerRpc(map[uint16]{{.RegPlayerRpcPack}}.PlayerRpc{
			{{range .PlayerRpc}}enum.{{.Name}}: {{.Pack}}.{{.Name}},
			{{end}}
		})
	{{end}}
	{{if .HttpHandleCnt}}
		register.RegHttpHandler(map[string]register.HttpHandle{
			{{range .HttpHandle}}"/{{.Name}}": {{.Pack}}.Http_{{.Name}},
			{{end}}
		})
	{{end}}
}
`

func (self *RpcInfo) makeFile(svr string) {
	filename := K_RegistFileName
	tpl, err := template.New(filename).Parse(codeRegistTemplate)
	if err != nil {
		panic(err.Error())
		return
	}
	var bf bytes.Buffer
	if err = tpl.Execute(&bf, self); err != nil {
		panic(err.Error())
		return
	}
	if err = os.MkdirAll(K_RegistOutDir+svr, 0777); err != nil {
		panic(err.Error())
		return
	}
	f, err := os.OpenFile(K_RegistOutDir+svr+"/"+filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
	if err != nil {
		panic(err.Error())
		return
	}
	defer f.Close()
	f.Write(bf.Bytes())
}
func (p *RpcInfo) RpcCnt() int        { return len(p.TcpRpc) + len(p.HttpRpc) + len(p.PlayerRpc) }
func (p *RpcInfo) TcpRpcCnt() int     { return len(p.TcpRpc) }
func (p *RpcInfo) HttpRpcCnt() int    { return len(p.HttpRpc) }
func (p *RpcInfo) PlayerRpcCnt() int  { return len(p.PlayerRpc) }
func (p *RpcInfo) HttpHandleCnt() int { return len(p.HttpHandle) }
